// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package item

import (
	"context"
	"github.com/google/uuid"
	"sync"
)

// Ensure, that RepositoryMock does implement Repository.
// If this is not the case, regenerate this file with moq.
var _ Repository = &RepositoryMock{}

// RepositoryMock is a mock implementation of Repository.
//
//	func TestSomethingThatUsesRepository(t *testing.T) {
//
//		// make and configure a mocked Repository
//		mockedRepository := &RepositoryMock{
//			AddItemFunc: func(ctx context.Context, name string, price Decimal, manufacturer string) (Item, error) {
//				panic("mock out the AddItem method")
//			},
//			GetItemByIDFunc: func(ctx context.Context, id uuid.UUID) (Item, error) {
//				panic("mock out the GetItemByID method")
//			},
//			GetItemsFunc: func(ctx context.Context, page int64, pageSize int64) ([]Item, error) {
//				panic("mock out the GetItems method")
//			},
//			RemoveItemFunc: func(ctx context.Context, id uuid.UUID) (uuid.UUID, error) {
//				panic("mock out the RemoveItem method")
//			},
//			UpdateItemFunc: func(ctx context.Context, item *Item) (Item, error) {
//				panic("mock out the UpdateItem method")
//			},
//		}
//
//		// use mockedRepository in code that requires Repository
//		// and then make assertions.
//
//	}
type RepositoryMock struct {
	// AddItemFunc mocks the AddItem method.
	AddItemFunc func(ctx context.Context, name string, price Decimal, manufacturer string) (Item, error)

	// GetItemByIDFunc mocks the GetItemByID method.
	GetItemByIDFunc func(ctx context.Context, id uuid.UUID) (Item, error)

	// GetItemsFunc mocks the GetItems method.
	GetItemsFunc func(ctx context.Context, page int64, pageSize int64) ([]Item, error)

	// RemoveItemFunc mocks the RemoveItem method.
	RemoveItemFunc func(ctx context.Context, id uuid.UUID) (uuid.UUID, error)

	// UpdateItemFunc mocks the UpdateItem method.
	UpdateItemFunc func(ctx context.Context, item *Item) (Item, error)

	// calls tracks calls to the methods.
	calls struct {
		// AddItem holds details about calls to the AddItem method.
		AddItem []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Name is the name argument value.
			Name string
			// Price is the price argument value.
			Price Decimal
			// Manufacturer is the manufacturer argument value.
			Manufacturer string
		}
		// GetItemByID holds details about calls to the GetItemByID method.
		GetItemByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID uuid.UUID
		}
		// GetItems holds details about calls to the GetItems method.
		GetItems []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Page is the page argument value.
			Page int64
			// PageSize is the pageSize argument value.
			PageSize int64
		}
		// RemoveItem holds details about calls to the RemoveItem method.
		RemoveItem []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID uuid.UUID
		}
		// UpdateItem holds details about calls to the UpdateItem method.
		UpdateItem []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Item is the item argument value.
			Item *Item
		}
	}
	lockAddItem     sync.RWMutex
	lockGetItemByID sync.RWMutex
	lockGetItems    sync.RWMutex
	lockRemoveItem  sync.RWMutex
	lockUpdateItem  sync.RWMutex
}

// AddItem calls AddItemFunc.
func (mock *RepositoryMock) AddItem(ctx context.Context, name string, price Decimal, manufacturer string) (Item, error) {
	if mock.AddItemFunc == nil {
		panic("RepositoryMock.AddItemFunc: method is nil but Repository.AddItem was just called")
	}
	callInfo := struct {
		Ctx          context.Context
		Name         string
		Price        Decimal
		Manufacturer string
	}{
		Ctx:          ctx,
		Name:         name,
		Price:        price,
		Manufacturer: manufacturer,
	}
	mock.lockAddItem.Lock()
	mock.calls.AddItem = append(mock.calls.AddItem, callInfo)
	mock.lockAddItem.Unlock()
	return mock.AddItemFunc(ctx, name, price, manufacturer)
}

// AddItemCalls gets all the calls that were made to AddItem.
// Check the length with:
//
//	len(mockedRepository.AddItemCalls())
func (mock *RepositoryMock) AddItemCalls() []struct {
	Ctx          context.Context
	Name         string
	Price        Decimal
	Manufacturer string
} {
	var calls []struct {
		Ctx          context.Context
		Name         string
		Price        Decimal
		Manufacturer string
	}
	mock.lockAddItem.RLock()
	calls = mock.calls.AddItem
	mock.lockAddItem.RUnlock()
	return calls
}

// GetItemByID calls GetItemByIDFunc.
func (mock *RepositoryMock) GetItemByID(ctx context.Context, id uuid.UUID) (Item, error) {
	if mock.GetItemByIDFunc == nil {
		panic("RepositoryMock.GetItemByIDFunc: method is nil but Repository.GetItemByID was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uuid.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetItemByID.Lock()
	mock.calls.GetItemByID = append(mock.calls.GetItemByID, callInfo)
	mock.lockGetItemByID.Unlock()
	return mock.GetItemByIDFunc(ctx, id)
}

// GetItemByIDCalls gets all the calls that were made to GetItemByID.
// Check the length with:
//
//	len(mockedRepository.GetItemByIDCalls())
func (mock *RepositoryMock) GetItemByIDCalls() []struct {
	Ctx context.Context
	ID  uuid.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  uuid.UUID
	}
	mock.lockGetItemByID.RLock()
	calls = mock.calls.GetItemByID
	mock.lockGetItemByID.RUnlock()
	return calls
}

// GetItems calls GetItemsFunc.
func (mock *RepositoryMock) GetItems(ctx context.Context, page int64, pageSize int64) ([]Item, error) {
	if mock.GetItemsFunc == nil {
		panic("RepositoryMock.GetItemsFunc: method is nil but Repository.GetItems was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Page     int64
		PageSize int64
	}{
		Ctx:      ctx,
		Page:     page,
		PageSize: pageSize,
	}
	mock.lockGetItems.Lock()
	mock.calls.GetItems = append(mock.calls.GetItems, callInfo)
	mock.lockGetItems.Unlock()
	return mock.GetItemsFunc(ctx, page, pageSize)
}

// GetItemsCalls gets all the calls that were made to GetItems.
// Check the length with:
//
//	len(mockedRepository.GetItemsCalls())
func (mock *RepositoryMock) GetItemsCalls() []struct {
	Ctx      context.Context
	Page     int64
	PageSize int64
} {
	var calls []struct {
		Ctx      context.Context
		Page     int64
		PageSize int64
	}
	mock.lockGetItems.RLock()
	calls = mock.calls.GetItems
	mock.lockGetItems.RUnlock()
	return calls
}

// RemoveItem calls RemoveItemFunc.
func (mock *RepositoryMock) RemoveItem(ctx context.Context, id uuid.UUID) (uuid.UUID, error) {
	if mock.RemoveItemFunc == nil {
		panic("RepositoryMock.RemoveItemFunc: method is nil but Repository.RemoveItem was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uuid.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockRemoveItem.Lock()
	mock.calls.RemoveItem = append(mock.calls.RemoveItem, callInfo)
	mock.lockRemoveItem.Unlock()
	return mock.RemoveItemFunc(ctx, id)
}

// RemoveItemCalls gets all the calls that were made to RemoveItem.
// Check the length with:
//
//	len(mockedRepository.RemoveItemCalls())
func (mock *RepositoryMock) RemoveItemCalls() []struct {
	Ctx context.Context
	ID  uuid.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  uuid.UUID
	}
	mock.lockRemoveItem.RLock()
	calls = mock.calls.RemoveItem
	mock.lockRemoveItem.RUnlock()
	return calls
}

// UpdateItem calls UpdateItemFunc.
func (mock *RepositoryMock) UpdateItem(ctx context.Context, item *Item) (Item, error) {
	if mock.UpdateItemFunc == nil {
		panic("RepositoryMock.UpdateItemFunc: method is nil but Repository.UpdateItem was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Item *Item
	}{
		Ctx:  ctx,
		Item: item,
	}
	mock.lockUpdateItem.Lock()
	mock.calls.UpdateItem = append(mock.calls.UpdateItem, callInfo)
	mock.lockUpdateItem.Unlock()
	return mock.UpdateItemFunc(ctx, item)
}

// UpdateItemCalls gets all the calls that were made to UpdateItem.
// Check the length with:
//
//	len(mockedRepository.UpdateItemCalls())
func (mock *RepositoryMock) UpdateItemCalls() []struct {
	Ctx  context.Context
	Item *Item
} {
	var calls []struct {
		Ctx  context.Context
		Item *Item
	}
	mock.lockUpdateItem.RLock()
	calls = mock.calls.UpdateItem
	mock.lockUpdateItem.RUnlock()
	return calls
}
